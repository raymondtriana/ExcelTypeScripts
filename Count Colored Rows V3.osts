{"version":"0.2.0","body":"/*\nAUTHOR: Raymond Levi Triana\nPURPOSE: keep track of how many people have been accepted, in process, or rejected, sort table according to these color codes, and moves those rejected or accepted to a separate worksheet.\n*/\n\n/*map used to keep count of rows by color in all tables*/\nlet colorTracker = new Map<string, number>([\n  [\"#FF0000\", 0],//RED\n  [\"#00B050\", 0],//Green\n  [\"#FFC000\", 0],//ORANGE\n  [\"#FFFFFF\", 0]//WHITE\n]);\n\nfunction main(workbook: ExcelScript.Workbook) {\n  //used as offsets when reading table1 should be replaced with get table\n\n  if (checkMainTable(workbook, [\"#FF0000\", \"#00B050\"])) {\n    moveTableRows(workbook.getTable(\"mainTable\"), workbook.getTable(\"redTable\"), \"#FF0000\");//move red rows\n    moveTableRows(workbook.getTable(\"mainTable\"), workbook.getTable(\"greenTable\"),\"#00B050\");//move green rows\n  }\n  \n    countTableRows(workbook.getTable(\"redTable\"),\"#FF0000\");//count red rows\n    countTableRows(workbook.getTable(\"greenTable\"), \"#00B050\");//count green rows\n  \n    printColorTracker(workbook);\n    sortTable(workbook.getTable(\"mainTable\"));\n  return;\n}\n\nfunction checkMainTable(workbook: ExcelScript.Workbook, colorFilter: Array<string>) {\n  /*Checks the mainTable to see if cutting and pasting is required\n    increments the counters for orange and white */\n\n  let tableRef = workbook.getTable(\"mainTable\")\n  let startRowNumber = tableRef.getRange().getRowIndex();\n  let endRowNumber = tableRef.getRange().getRowCount() + tableRef.getRange().getRowIndex()\n  let rowArray = tableRef.getRange().getNumberFormats();\n\n  let returnFlag = false;//used to notify whether cutting and pasting rows is required\n\n  rowArray.forEach((rowItem, rowIndex) => {\n    let cellRef = tableRef.getRange().getCell(rowIndex, 0);\n    let cellColor = cellRef\n      .getFormat()\n      .getFill()\n      .getColor();\n\n    tableRef.getRange().getCell(rowIndex, 25).setValue(cellColor);//update HEX Column\n\n    if (colorTracker.has(cellColor) && cellRef.getValue() != \"\") {//Ignore blank rows\n      incrementColorTracker(cellColor);\n      console.log\n    }\n    if (colorFilter.includes(cellColor)) {\n      returnFlag = true;\n    }\n  });\n  return returnFlag;\n}\n\nfunction incrementColorTracker(color: string) {\n  /*increment the input color's value in color tracker*/\n  colorTracker.set(color, colorTracker.get(color) + 1);\n  return;\n}\n\nfunction printColorTracker(workbook: ExcelScript.Workbook) {\n  /*Prints the colorTracker map onto row 2 under corresponding color */\n  /*MAY WANT TO UPDATE TO NOT BE RELIANT ON VARIABLE IN $B2(Line:74)*/\n  let endOfColors = workbook\n    .getWorksheet(\"main\")\n    .getCell(1, 1)\n    .getText();\n  let range = workbook\n    .getWorksheet(\"main\")\n    .getRange(\"C1:\" + endOfColors);\n  let rowArray = range\n    .getNumberFormats();\n\n  rowArray.forEach((rowItem, rowIndex) => {\n    rowArray[rowIndex].forEach((columnItem, columnIndex) => {\n\n      let cellRef = range\n        .getCell(rowIndex, columnIndex);\n      let outputCell = range\n        .getCell(rowIndex + 1, columnIndex);\n\n      if (colorTracker.has(cellRef.getFormat().getFill().getColor())) {//if color exists in dictionary\n\n        outputCell.setValue(colorTracker.get(cellRef.getFormat().getFill().getColor()));\n\n      } else {//if color doesnt exist in dictionary output hex value\n\n        outputCell.setValue(cellRef.getFormat().getFill().getColor());\n\n      }\n\n    });\n  });\n  return;\n}\n\nfunction sortTable(tableRef: ExcelScript.Table) {\n  /*Sort table based on hex values in column Z */\n  let tableRef_L = tableRef;\n  tableRef_L.getSort().apply([{ key: 25, ascending: true }])\n  return;\n}\n\nfunction moveTableRows(sourceTableRef: ExcelScript.Table, targetTableRef: ExcelScript.Table, colorFilter: string) {\n  /*cuts the rows of a table according to the hex value \"colorFilter\" and pastes them into a table in another worksheet*/\n  const filter_column = 25;//the column where the HEX value of the row's color is stored\n  let rowsToDelete: string[] = [];\n\n  if (!targetTableRef || !sourceTableRef) {\n    console.log(\"Either the target or source table pointers are NULL\");\n  }\n  /*UNNECESSARY*/\n  const table_filters = {};\n  sourceTableRef.getColumns().forEach((column) => {\n    let column_filter_criteria = column.getFilter().getCriteria();\n    //store the filters applied on the source table\n    if (column_filter_criteria) {\n      delete column_filter_criteria['@odata.type'];\n      delete column_filter_criteria['subfield'];\n      table_filters[column.getName()] = column_filter_criteria;\n    }\n  });\n  /*/UNNECESSARY*/\n\n  const source_table_range = sourceTableRef.getRangeBetweenHeaderAndTotal();//stores the range of the body of the table\n  const source_data_rows = source_table_range.getValues();//stores the rows of the table\n\n  const source_rows_to_move: (number | string | boolean)[][] = [];\n  let deleteRef={};\n  for (let i = 0; i < source_data_rows.length; i++) {\n    if (source_data_rows[i][filter_column] as string === colorFilter) {\n      source_rows_to_move.push(source_data_rows[i]);\n      let address = source_table_range.getRow(i).getAddress();\n      rowsToDelete.push(address);\n    }\n  }\n  let sheet = sourceTableRef.getWorksheet();\n  try{\n    targetTableRef.addRows(-1, source_rows_to_move);//Insert row into target table\n  } catch{//skip deleting rows and immediately return if insert fails\n      return;\n    }\n    /*remove row from source table */\n    sourceTableRef.getAutoFilter().clearCriteria();//clear filters on source table\n    rowsToDelete.reverse().forEach((address) => {\n      sheet.getRange(address).delete(ExcelScript.DeleteShiftDirection.up);\n    });\n\n}\n\nfunction countTableRows(targetTable: ExcelScript.Table, colorFilter: string) {\n  /*counts the table size of the target table and sets ColorTracker's value to that*/\n  colorTracker.set(colorFilter, targetTable.getRowCount());\n  return;\n}\n","description":"","parameterInfo":"{\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}